/* Machine generated: ${new Date()} */
/* Database information: */
<% info.each { %>/*  <%= it.key %>: <%= it.value %> */
<% } %>
<% // vim: set syntax=groovy : %>
MACHINE data
/* TODO:
 * Decide how to select courses for checking (major and minor pairs, major only courses and/or major and focus area)
 *  - Build all pairs ahead of time
 *  - Choose to options
 *  - Provide a faculty configuration which things can be selected by the user
 * Add an assertion that all levels with modules are leaves
 * Generate docs along with data
 */
DEFINITIONS
 "LibraryIO.def";
 SEMESTERS==1..6;
SETS
    TYPES={m,e};
    // MODULES={<%= modules.collect { it.name }.join(', ') %>};
    SLOTS = {a1,a2,a3,a4,a5,
             b1,b2,b3,b4,b5,
             c1,c2,c3,c4,c5,
             d1,d2,d3,d4,d5,
             e1,e2,e3,e4,e5,
             f1,f2,f3,f4,f5,
             g1,g2,g3,g4,g5,
             unknown};

    PRIORITIES={P,W,S,F};
    DAYS = {mon, tue, wed, thu, fri, sat, sun}
CONSTANTS
    abstract_units,
    abstract_unit_unit_semester,
    courses,
    course_levels,
    course_modules,
    course_tree_leaves,
    LEVELS,
    level_modules,
    sessions,
    units,
    modules,
    module_abstract_unit_semester
PROPERTIES
    modules : POW(NATURAL1 * struct(idx:NATURAL1, name:STRING, title:STRING, pordnr:NATURAL, mandatory:BOOL))
    &
    modules = {
        <%=
        modules.collect { module ->
            "(${module.id} |-> rec(idx:${module.id}, name:\"${module.name}\", title:\"${module.title}\", pordnr:${module.pordnr}, mandatory:${(module.mandatory)?'TRUE':'FALSE'}))"
        }.join(',\n        ')
        %>
    }
    &
    courses : POW(STRING*struct(idx:NATURAL1, name:STRING, long_name:STRING, degree:STRING, po:NATURAL1, kzfa:STRING))
    &
    courses = {
        <%=
        courses.collect { course ->
            "(\"${course.name}\" |-> rec(idx: ${course.id}, name: \"${course.name}\", long_name:\"${course.fullName}\", degree:\"${course.degree}\", kzfa:\"${course.kzfa}\", po:${course.po}))"
        }.join(',\n        ')
        %>
    }
    &
    sessions : POW(NATURAL1 * struct(duration:INTEGER, rhythm:INTEGER, dow:DAYS, slot:NATURAL1))
    &
    sessions = {
        <%=
        sessions.collect { session ->
            "(${session.id}, rec(dow:${session.day}, slot:${session.time}, rhythm:${session.rhythm}, duration:${session.duration}))"
        }.join(',\n        ')
        %>
    }
    &
    abstract_units : POW(NATURAL1 * struct(idx:NATURAL, title:STRING, key:STRING, type: TYPES))
    &
    abstract_units = {
        <%=
        abstract_units.collect { au ->
            "(${au.id}, rec(idx:${au.id}, title:\"${au.title}\", key:\"${au.key}\", type:${au.type}))"
        }.join(',\n        ')
        %>
    }
    &
    module_abstract_unit_semester : POW((dom(modules) * dom(abstract_units)) * SEMESTERS)
    &
    module_abstract_unit_semester = {
        <%= module_abstract_unit_semester.collect { maus ->
            "(${maus.module.id}, ${maus.abstract_unit.id}, ${maus.semester})"
        }.join(',\n        ')
        %>
    }
    &
    units :  POW(NATURAL1 * struct(idx:NATURAL1, key:STRING, groups:POW(INTEGER*struct(sessions:POW(INTEGER))), title:STRING))
    &
    units = {
        <%=
        units.collect { unit ->
            "(${unit.id}, rec(idx:${unit.id}, title:\"${unit.title}\", key:\"${unit.key}\", groups:{${unit.groups.collect { group -> "(${group.id}, rec(sessions:{${group.sessions.collect { it.id }.join(', ')}}))"}.join(', ')}}))"
        }.join(',\n        ')
        %>
    }
    &
    abstract_unit_unit_semester : POW((dom(abstract_units) * dom(units)) * SEMESTERS)
    &
    abstract_unit_unit_semester = {
        <%=
        abstract_unit_unit_semester.collect { auas ->
            "(${auas.abstract_unit.id}, ${auas.unit.id}, ${auas.semester})"
        }.join(',\n        ')
        %>
    }
    &
    LEVELS = {<%= levels.collect { level -> level.id}.join (', ') %>}
    &
    course_levels : dom(courses) <-> tree(struct(idx: LEVELS, art:STRING, name: STRING, tm: STRING, from: NATURAL \\/ {-1}, to: NATURAL \\/ {-1}))
    &
    #(<%= levels.toList().collate(10).collect { it.collect { level -> "level_${level.id}" }.join(', ') }.join(',\n        ') %>).(
    <% levels.each { level -> %>
        level_<%= level.id %> : tree(struct(idx: LEVELS, art:STRING, name: STRING, tm: STRING, from: NATURAL \\/ {-1}, to: NATURAL \\/ {-1}))
        &
        level_<%= level.id %> = <%if(level.children.size() >0) { %>
            const(rec(idx:${level.id}, art:"${level.art}", name:"${level.name}", tm:"${level.tm}", from:${level.min}, to:${level.max}), [<%= level.children.collect { child -> "level_${child.id}" }.join(', ') %>])<% } else { %>
            bin(rec(idx:${level.id}, art:"${level.art}", name:"${level.name}", tm:"${level.tm}", from:${level.min}, to:${level.max}))
        <% } %><% if (level != levels.last()) { %> & <% } %><% } %>
      &
      course_levels = {
        <%= courses.collect { course -> course.levels.collect { level -> "(\"${course.name}\", level_${level.id})"}.join(', ') }.join(',\n        ') %>
      }
    )
    &
    /*
     * Maps from level ID to the set of modules associated with that level (leaf)
     */
    level_modules : LEVELS <-> dom(modules)
    &
    level_modules = {
        <%= levels.findAll { level -> level.modules.size() > 0 }.collect { level ->
             level.modules.collect { module -> "(${level.id} |-> ${module.id})" }.join(", ")
        }.join(',\n        ') %>
    }
    &
    course_tree_leaves : POW((dom(courses)*LEVELS)*POW(LEVELS))
    &
    !(cc, tt).( cc : dom(courses) & tt : course_levels[{cc}] =>
        course_tree_leaves(cc, top(tt)'idx) = {y | #(x).(x : dom(tt) & sizet(subtree(tt, x)) = 1 & y = tt(x)'idx)}
    )
    &
    course_modules : dom(courses) --> POW(dom(modules))
    &
    course_modules = {
        <% courses.each { course -> %>
        ("<%= course.name %>", {<%= course.modules.collect { it.id }.join(" ,") %>})<% if(course != courses.last()) { %>,<% } %><% } %>
    }

END
