/* vim: set syntax=B : */
/* Machine generated: ${new Date()} */
/* Model generator version: 3.0.0-SNAPSHOT */
/* Database information: */
<% info.each { %>/*  <%= it.key %>: <%= it.value %> */
<% } %>
<% // vim: set syntax=groovy : %>
MACHINE data
/* TODO:
 * Decide how to select courses for checking (major and minor pairs, major only courses and/or major and focus area)
 *  - Build all pairs ahead of time
 *  - Choose to options
 *  - Provide a faculty configuration which things can be selected by the user
 * Generate docs along with data
 */
DEFINITIONS
  "LibraryIO.def";
  "LibraryStrings.mch";
  XML_ELement_Type == struct(
                        recId: NATURAL1,
                        pId:NATURAL,
                        element:STRING,
                        attributes: STRING +-> STRING,
                        meta: STRING +-> STRING);
  EXTERNAL_FUNCTION_READ_XML == STRING --> seq(XML_ELement_Type);
  READ_XML(file) == {};
SETS
    TYPES={m,e};
    DAYS = {mon, tue, wed, thu, fri, sat, sun};
    SLOTS = {<%= (1..8).collect { "slot${it}" }.join(", ") %>};
    SEMESTERS = {<%= (1..6).collect { "sem${it}" }.join(", ") %>};
    ABSTRACT_UNITS = {<%= abstract_units.collate(20, 20).collect { row -> row.collect { "au${it.id}" }.join(", ") }.join(",\n          ") %>};
    UNITS = {<%= units.collate(20, 20).collect { row -> row.collect{ "unit${it.id}" }.join(", ") }.join(",\n          ") %>};
    GROUPS = {<%= groups.collate(20, 20).collect { row -> row.collect{ "group${it.id}" }.join(", ") }.join(",\n          ") %>};
    SESSIONS = {<%= sessions.collate(20, 20).collect { row -> row.collect { "session${it.id}" }.join(", ") }.join(",\n          ") %>};
    MODULES = {<%= modules.collate(20, 20).collect { row -> row.collect { "mod${it.id}" }.join(", ") }.join(",\n          ") %>}
CONSTANTS
    abstract_units,
    abstract_unit_unit,
    courses,
    course_names,
    course_modules,
    course_module_combinations,
    sessions,
    units,
    meta_data,
    modules,
    module_abstract_unit_semester,
    module_abstract_unit_type,
    course_module_combination_data
PROPERTIES
    meta_data = {
        <%= info.collect { "(\"${it.key}\", \"${it.value}\")" }.join(",\n        ") %>
    }
    &
    modules : POW(MODULES * struct(idx:NATURAL1, name:STRING, key:STRING, credit_points:NATURAL \\/ {-1}, title:STRING, pordnr:NATURAL, elective_units:NATURAL, mandatory:BOOL))
    &
    modules = {
        <%=
        modules.collect { module ->
            "(mod${module.id} |-> rec(idx:${module.id}, name:\"${module.name}\", key:\"${module.key}\", credit_points:${module.credit_points}, title:\"${module.title}\", pordnr:${module.pordnr}, elective_units:${module.elective_units},  mandatory:${(module.mandatory)?'TRUE':'FALSE'}))"
        }.join(',\n        ')
        %>
    }
    &
    courses : POW(STRING * struct(idx:NATURAL1, name:STRING, long_name:STRING, degree:STRING, credit_points:NATURAL \\/ {-1}, po:NATURAL1, kzfa:STRING))
    &
    courses = {
        <%=
        courses.collect { course ->
            "(\"${course.key}\" |-> rec(idx: ${course.id}, name: \"${course.key}\", long_name:\"${course.fullName}\", credit_points:${course.credit_points}, degree:\"${course.degree}\", kzfa:\"${course.kzfa}\", po:${course.po}))"
        }.join(',\n        ')
        %>
    }
    &
    course_names : POW(dom(courses))
    &
    course_names = dom(courses)
    &
    course_module_combination_data = READ_XML("${short_name.value}-data.xml") &  course_module_combination_data : seq(XML_ELement_Type)
    &
    course_module_combinations : course_names --> POW(POW(MODULES))
    &
    course_module_combinations =
      LET helper BE
        helper = UNION(x, y).((x,y) : course_module_combination_data & y'pId /= 0 |
        LET
            attrs
        BE
            attrs = y'attributes
        IN
            LET
                mods
            BE
                mods = ran(STRING_SPLIT(attrs("value"), ","))
            IN
                {(attrs("course") |-> UNION(n).(n : mods | {STRING_TO_ENUM(n)}))}
            END
        END)
      IN
        %(x).(x : course_names | helper[{x}])
      END
    &
    sessions : POW(SESSIONS * struct(duration:INTEGER, rhythm:INTEGER, dow:DAYS, slot:SLOTS))
    &
    sessions = {
        <%=
        sessions.collect { session ->
            "(session${session.id}, rec(dow:${session.day}, slot:slot${session.time}, rhythm:${session.rhythm}, duration:${session.duration}))"
        }.join(',\n        ')
        %>
    }
    &
    abstract_units : POW(ABSTRACT_UNITS * struct(idx:NATURAL, title:STRING, key:STRING))
    &
    abstract_units = {
        <%=
        abstract_units.collect { au ->
            "(au${au.id}, rec(idx:${au.id}, title:\"${au.title}\", key:\"${au.key}\"))"
        }.join(',\n        ')
        %>
    }
    &
    module_abstract_unit_semester : POW((MODULES * ABSTRACT_UNITS) * SEMESTERS)
    &
    module_abstract_unit_semester = {
        <%= module_abstract_unit_semester.collect { maus ->
            "(mod${maus.module.id}, au${maus.abstract_unit.id}, sem${maus.semester})"
        }.join(',\n        ')
        %>
    }
    &
    module_abstract_unit_type : ((MODULES*ABSTRACT_UNITS)<->TYPES)
    &
    module_abstract_unit_type = {
        <%= module_abstract_unit_type.collect { maut ->
            "(mod${maut.module.id}, au${maut.abstract_unit.id}, ${maut.type})"
        }.join(',\n        ')
        %>
    }
    &
    units :  POW(UNITS * struct(idx:NATURAL1, key:STRING, semesters: POW(SEMESTERS), groups:POW(GROUPS * struct(half_semester:0..2, sessions:POW(SESSIONS))), title:STRING))
    &
    units = {
        <%=
        units.collect { unit ->
            "(unit${unit.id}, rec(idx:${unit.id}, title:\"${unit.title}\", key:\"${unit.key}\", semesters:{${unit.semesters.collect { sem -> "sem${sem}" }.join(", ") }}, groups:{${unit.groups.collect { group -> "(group${group.id}, rec(half_semester:${group.half_semester}, sessions:{${group.sessions.collect { "session${it.id}" }.join(', ')}}))"}.join(', ')}}))"
        }.join(',\n        ')
        %>
    }
    &
    abstract_unit_unit : POW(ABSTRACT_UNITS * UNITS)
    &
    abstract_unit_unit = {
        <%=
        abstract_units.findAll { it.units.size() > 0 }.collect { au ->
                au.units.collect { u ->
                        "(au${au.id}, unit${u.id})"
                }.join(',\n        ')
        }.join(',\n        ')
        %>
    }
    &
    course_modules : course_names --> POW(MODULES)
    &
    course_modules = {
        <% courses.each { course -> %>
        ("<%= course.key %>", {<%= course.modules.collect { "mod${it.id}" }.join(" ,") %>})<% if(course != courses.last()) { %>,<% } %><% } %>
    }
ASSERTIONS
  course_names = dom(course_module_combinations)
END
